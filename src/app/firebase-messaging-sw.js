
// Import the PWA service worker generated by next-pwa
import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate } from 'workbox-strategies';

// Import Firebase SDKs
import { initializeApp } from 'firebase/app';
import { getMessaging, onBackgroundMessage } from 'firebase/messaging/sw';

console.log('[SW] Service Worker script started.');

// This is the placeholder for the workbox manifest.
// next-pwa will inject the actual manifest here.
precacheAndRoute(self.__WB_MANIFEST);

// Give the service worker a name for debugging
self.name = 'BroosV2ServiceWorker';

// Example of caching strategy for assets
registerRoute(
  ({ request }) => request.destination === 'image',
  new StaleWhileRevalidate({
    cacheName: 'images',
  })
);


// --- FIREBASE MESSAGING INITIALIZATION ---

// Your web app's Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyBVOId-CRlTD6oKqvZ0CxKSFxObOoHEHd8",
  authDomain: "studio-5690519872-e0869.firebaseapp.com",
  projectId: "studio-5690519872-e0869",
  storageBucket: "studio-5690519872-e0869.appspot.com",
  messagingSenderId: "796529432751",
  appId: "1:796529432751:web:da147b13f407d67aaf9c5a",
  measurementId: "G-14976CYFEK"
};

try {
    // Initialize the Firebase app in the service worker
    const app = initializeApp(firebaseConfig);
    const messaging = getMessaging(app);

    console.log('[SW] Firebase Messaging Service Worker initialized successfully.');

    // This handler will be called when a push notification is received
    // while the app is in the background or closed.
    onBackgroundMessage(messaging, (payload) => {
      console.log('[SW] Received background message: ', payload);

      // Customize the notification here
      const notificationTitle = payload.notification?.title || 'Broos 2.0 Melding';
      const notificationOptions = {
        body: payload.notification?.body || 'Je hebt een nieuw bericht.',
        icon: '/icons/icon-192x192.png',
        badge: '/icons/icon-72x72.png',
        data: {
            url: payload.fcmOptions?.link || '/'
        }
      };

      self.registration.showNotification(notificationTitle, notificationOptions);

       // Update the app badge
      if (navigator.setAppBadge) {
        navigator.setAppBadge(1);
      }
    });
} catch(error) {
    console.error('[SW] CRITICAL: Failed to initialize Firebase Messaging in Service Worker.', error);
}


// This event listener handles notification clicks.
self.addEventListener('notificationclick', (event) => {
    console.log('[SW] Notification click received.', event.notification.data);
    event.notification.close();

    const urlToOpen = new URL(event.notification.data.url || '/', self.location.origin).href;

    event.waitUntil(
        self.clients.matchAll({
            type: 'window',
            includeUncontrolled: true,
        }).then((clientList) => {
            for (let i = 0; i < clientList.length; i++) {
                const client = clientList[i];
                if (client.url === urlToOpen && 'focus' in client) {
                    return client.focus();
                }
            }
            if (self.clients.openWindow) {
                return self.clients.openWindow(urlToOpen);
            }
        })
    );
});

// This makes sure the new service worker activates immediately
self.addEventListener('install', () => {
    console.log('[SW] New service worker installing... will skip waiting.');
    self.skipWaiting();
});

// This handles clearing the app badge when the app is opened/focused
self.addEventListener('activate', (event) => {
    console.log('[SW] Service worker activated. Claiming clients.');
    event.waitUntil(
        self.clients.claim().then(() => {
            if (navigator.clearAppBadge) {
                console.log('[SW] Clearing app badge.');
                navigator.clearAppBadge();
            }
        })
    );
});
