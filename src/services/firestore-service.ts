'use server';

import { getFirebaseAdmin } from '@/ai/genkit';
import { serverTimestamp } from 'firebase-admin/firestore';
import { format } from "date-fns";
import type { Alert, OnboardingTopic, UserProfile, WellnessScore, WellnessAnalysisOutput } from '@/lib/types';
import type { DocumentReference } from 'firebase-admin/firestore';


/**
 * Saves the summary for a completed onboarding topic to the user's profile.
 * Also handles the final flag update when all topics are done.
 * 
 * @param userRef Reference to the user's Firestore document.
 * @param userProfile The current user profile data.
 * @param topic The topic that was just completed.
 * @param summary The AI-generated summary for the topic.
 */
export async function saveOnboardingSummary(
    userRef: DocumentReference,
    userProfile: UserProfile,
    topic: OnboardingTopic,
    summary: string,
) {
  console.log(`[Firestore Service] Saving onboarding summary for topic: ${topic}`);

  const updateData: Partial<UserProfile> = {
    [topic]: summary,
  };
  
  // Check if this completion finishes the onboarding process.
  const allTopics: OnboardingTopic[] = [
    "familySituation", "schoolSituation", "personalGoals", 
    "matchPreparation", "recoveryHabits", "additionalHobbies"
  ];
  const isNowFullyComplete = allTopics.every(t => (t in userProfile) || t === topic);
  
  if (isNowFullyComplete) {
    console.log("[Firestore Service] All topics are now complete. Finalizing onboarding.");
    updateData.onboardingCompleted = true;
  }
  
  await userRef.update(updateData);
}


/**
 * Saves all wellness-related data (scores, alerts, summary) generated by the AI
 * during a regular chat session. This is done as a single logical operation.
 * 
 * @param userId The ID of the user.
 * @param aiOutput The full output from the wellness analysis AI flow.
 */
export async function saveWellnessData(
  userId: string,
  aiOutput: WellnessAnalysisOutput
) {
  console.log(`[Firestore Service] Saving wellness data for user: ${userId}`);
  const { adminDb } = getFirebaseAdmin();
  const today = format(new Date(), 'yyyy-MM-dd');
  
  // We don't use a batch here because each write is to a different subcollection
  // and they can happen in parallel without transactional integrity issues.

  const promises: Promise<any>[] = [];

  // 1. Save wellness scores if they exist
  if (aiOutput.wellnessScores && Object.keys(aiOutput.wellnessScores).length > 0) {
    const scoreRef = adminDb.collection('users').doc(userId).collection('wellnessScores').doc(today);
    const scoresToSave: Partial<WellnessScore> = {
      ...aiOutput.wellnessScores,
      id: today,
      date: today,
      updatedAt: serverTimestamp() as any, 
    };
    promises.push(scoreRef.set(scoresToSave, { merge: true }));
    console.log(`[Firestore Service] Queued wellness scores for saving.`);
  }

  // 2. Save alert if it exists
  if (aiOutput.alert) {
    const alertRef = adminDb.collection('users').doc(userId).collection('alerts').doc();
    const alertToSave: Alert = {
      ...aiOutput.alert,
      id: alertRef.id,
      userId,
      date: today,
      status: 'new',
      createdAt: serverTimestamp() as any,
    };
    promises.push(alertRef.set(alertToSave));
    console.warn(`[Firestore Service] Queued alert for saving: ${aiOutput.alert.alertType}`);
  }

  // 3. Save daily chat summary if it exists
  if (aiOutput.summary) {
    const chatRef = adminDb.collection('users').doc(userId).collection('chats').doc(today);
    const chatDataToSave = {
      id: today,
      userId,
      date: today,
      summary: aiOutput.summary,
      updatedAt: serverTimestamp() as any,
    };
    promises.push(chatRef.set(chatDataToSave, { merge: true }));
    console.log(`[Firestore Service] Queued daily chat summary for saving.`);
  }

  // Wait for all Firestore write operations to complete
  await Promise.all(promises);
  console.log(`[Firestore Service] All wellness data saved for user: ${userId}`);
}
